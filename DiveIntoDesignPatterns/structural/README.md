### 结构型模式
> 结构型模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。


### 抽象类和接口类有哪些区别?
1. 接口类不维护数据状态, 也不做任何实现, 它只提供一组接口声明.
> 继承了接口的类, 叫做具体类, 他们可以维护状态, 做实现.   

2. 抽象类维护(可能)数据状态, 可以做抽象方法的默认实现, 也可以不声明抽象方法.
`区别`
> 客户端围绕接口编程, 指的是客户端永远只会调用接口声明开放的方法, 不会去调用那些具体类公开出来的方法.     
> 客户端围绕抽象编程, 指的是客户端自行斟酌具体类(基于抽象类)有哪些方法, 那么客户端就根据自身的场景去调用哪些方法.    
> 面向接口编程只能解决通用问题, 而要解决特定问题一定是面向抽象编程.  


### 适配器(Adapter)
> 客户端根据接口提供的公共方法进行编程, 适配器则是两边黏合:   
> 1. 适配器类聚合具体类(具体类没有统一的接口), 具备访问具体类的所有方法.
> 2. 适配器类继承接口, 想办法使具体类的输出转换为与接口一致的行为.    
> 适配器让接口不兼容的对象能相互合作.


### 桥接(Bridge)
> 客户端根据具体类(基于抽象类)进行编程: 
> 1. 抽象类以聚合形式隐藏接口   
> 2. 抽象类提供一组抽象类用于表示该类至少要具备的行为   
> 3. 具体类可以扩展一些新的行为   
> 抽象类在抽象方法内与聚合的接口进行编程.


### 适配器和桥接有哪些区别?
1. [Adapter makes things work after they're designed; Bridge makes them work before they are. GoF, p219](https://stackoverflow.com/a/1425325/12353483)
2. 从客户端角度来看: 他们向的对象不一样.    
> 适配器: 客户端面向接口编程     
> 桥接: 客户端面向抽象类编程     
3. 从层次结构角度看:   
> 适配器: 适配器试图从单点进行横向扩展    
> 桥接: 试图从无结构拆分成树状结构     
> 面向接口编程只能解决通用问题, 而要解决特定问题一定是面向抽象编程.  


### 组合模式/对象树模式(Composite)
> 组合是一种结构型设计模式, 你可以使用它将对象组合成树状结构.   
> 结构由 `Leaf` 和 `Composite` 组成. 这两个组成结构都能像独立对象一样被使用,   
> 客户端可以对 `Leaf` 进行直接操作, 也可以对 `Composite` 容器进行操作.    
> 客户端也可以将多个 `Leaf` 添加到 `Composite` 中, 然后一起执行.     
> 客户端也可以将多个 `Leaf`、`Composite` 添加到 `Composite`中, 然后一起执行.    
> `Composite`一起执行, 可以起到递归效果.    
> 
> 如果应用的核心模型能用树状结构表示, 在应用中使用组合模式才有价值.   


### 装饰器模式(Decorator)
> 装饰器模式是在将 具体(原有)对象 包裹起来,    
> 再使装饰器具备在执行 具体(原有)对象 之前和之后可以附加一些其他操作.   
> 
> python中的装饰器很形象的描述装饰器的行为, 但是由于python是弱类型的原因而导致   
> 刚接触装饰器的人会觉得这是一个python特性, 是一种python特有的魔法技巧.  
> 
> 但其实这是一种设计模式, 在强类型的语言中有一套特定的方法论,    
> 跟python提供的decorator的代码风格截然不同.


### 外观模式(Facade)
> 传说中的面向客户端开发, 指的是所有的抽象都围绕着对客户端友好的操作而布局.
> 让客户端不需要关心背后的库怎么操作, 值需要指导外观对象提供了(封装了)什么.


### 享元模式(Flyweight)   
> 是什么?   
> 他摒弃了在每个对象中保存所有数据的方式, 通过共享多个对象所共有的相同状态,     
> 让你能在有限的内存容量中载入更多对象, Also known as: Cache.   
> 
>   
> 解决了什么问题?   
> 避免创建大量对象, 减少对象构造开销, 减少内存开销.
> 类似于fibonacci缓存, 对计算过的节点缓存, 减少重复计算.
>    
> 编码实现指导:     
> 1. 定义flyweight类:   
>   1.1 将类的成员变量按`可变数据(mutable)`和`不可变数据(immutable)`拆分开来.   
>   1.2 将`不可变数据`和`相关的函数`组成一个类, 这个类就叫做flyweight.  
>   1.3 flyweight的成员函数要为那些可变数据的类提供服务完成特定场景计算.
>   1.4 可变数据的类以聚合形式将flyweight当作成员变量, 在初始化的时候调用工厂方法去获取这个flyweight,
>       由于工厂方法是缓存的, 所以可变数据的类拿到的flyweight总是相同的对象.
> 
> 2. 定义工厂方法类:
>   2.1 定义一个私有成员变量: flyweight类的hash
>
>
> 1. 将对象的成员变量拆分成: 可变状态和不可变状态, 将不可变状态的数据和相关的行为分离出来做单独的类; 可变状态的数据和相关的行为分离出来做单独的类.   
> 2. 可变状态的类以聚合的形式将不可变状态的类当作成员变量.   
> 3. 利用工厂方法为可变状态的类提供缓存机制.   
> `1.` 和 `2.` 实现数据对象共享, `3.`实现场景对象共享.
>
> 哪些项目中使用到了享元模式?   
> TODO: 待补充
> 
