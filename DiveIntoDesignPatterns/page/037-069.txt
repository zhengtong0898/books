设计原则


封装变化的内容: 
	找到程度中的变化内容并将其与不变的内容区分开.
	如果变化的内容不复杂, 用一个函数来隔离(封装)起来即可, 
	如果变化的内容过于复杂, 用一个独立的类来再拆分.


面向接口进行开发, 而不是面向实现:
	与其依赖一个具体的类，不如依赖一个接口, 因为接口有明确定义某个方法, 这通常很难发生变化.
	接口可以作用再, 成员变量、方法参数、抽象方法中
	成员变量：声明一个接口对象, 实例化时根据特定场景初始化不同的派生类. 这种方式的
	         好处是: 可以根据不同的场景去不断新增派生类来满足需求而不需要改原有代码.
			 缺点是: 写代码之前都需要设计这个环节，而且设计代码时要多花点心思, 其他水平不到位的人无法直观的看懂你的代码.
	方法参数：声明一个形参对象是一个接口对象, 方法内调用的都是接口方法.
	         好处是: 基于该接口对象新增的对象都可以再当前方法中运行不会报错.
			 缺点是：写代码之前都需要设计这个环节，而且设计代码时要多花点心思, 其他水平不到位的人无法直观的看懂你的代码.
	抽象方法：声明一个抽象方法, 要求所有派生类都要各自实现这个抽象方法.


组合由于继承
	组合是代替继承的一种方法. 继承代表类之间的"是"关系(汽车是交通工具), 而组合则代表"有"关系(汽车有一个引擎).
	这个原则也能用于聚合(一对一, 一对多, 多对一, 多对多). 例如: 汽车上有司机, 但是司机也可能有其他能力(骑自行车, 开拖拉机).
	继承是纵向扩展，组合是横向扩展.





SOLID原则


单一职责原则(Single Responsibility Principle)
	尽量让每个类只负责软件中的一个功能, 并将该功能完全封装(隐藏)在该类中.
	一个复杂的功能, 可以使用十几个清晰的方法来完成, 总之封装就对了.
	十几个方法中, 如果某个方法依旧复杂, 则可以抽出来当作另外一个类, 与当前类组合关联.


开闭原则(Open/Closed Principle)
	如果一个类已经完成开发、测试和审核工作, 那么它就是稳定的版本, 除非有明确的理由, 否则不应该对它进行改动.
	如果要新增功能，或者改动功能，应该是重新写一个派生类，通过新增/覆盖的形式重写某部分功能(某些方法).
	这条原则不适用于那些尚未稳定的类中, 如果在未稳定的类中, 要修改就直接修改, 稳定后采取在参考这个原则.


里氏替换原则(Liskov Substitution Principle)
	这里强调的是派生类在覆盖/替换/重写基类的方法时, 需要的注意事项, 没有什么意义, 就不要做笔记了.
	重点在61-62页这两个图的类结构拆分.


接口隔离原则(Interface Segregation Principle)
	继承只允许拥有一个基类, 接口允许同时继承和实现多个接口.
	将接口精细化拆分, 是有效的隔离原则.


依赖倒置原则(Dependency Inversion Principle)
	高层次的类不应该依赖低层次的类, 而是应该依赖抽象的接口.
	高层次的类关联(永久拥有访问能力)低层次的类, 中间最好的方式是接口.

