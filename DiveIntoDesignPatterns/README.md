### 什么是设计模式
> 设计模式是前人大量打磨和锤炼出来的一套方法论, 解决那些一不小心就容易产生的耦合.


### 书籍
> 中文版: <深入设计模式>                 
> 英文版: <Dive Into Design Patterns>	
> 作者: Alexander Shvets;   
> 译者: 彭力


### 购买链接
> https://sourcemaking.com/design-patterns-ebook


### 备注
> 购买后:   
> [在这里下载英文版](https://sourcemaking.com/home)    
> [在这里下载中文版](https://refactoring.guru/u/home)


### 面向对象概念(page 013-019)
> 面向对象这种范式与其他范式主要的区别是: 抽象、封装、多态、继承, 这四个基本概念(面向对象多出这几个概念).    
>   
>   
> 抽象(Abstraction):   
> 	抽象的概念指的是针对具体的场景设定一个或多个类，每个类由一些数据属性(成员变量)和表现行为(成员函数)组成.   
>   
>   
> 封装(Encapsulation):   
> 	To encapsulate something means to make it private, and thus accessible only from within the methods of its own class.  
> 	封装某个内容意味着要将它私有化(private), 仅允许类内部调用它, 外部无法访问.  
> 	There's little bit less restrictive mode called protected that makes a member of a class available to subclass as well.  
> 	还有一种限制程度较小的关键字(protected), 允许派生类访问protected成员.  
>  
>  
> 继承(Inheritance)  
> 	The main benefit of inheritance is code reuse.  
> 	继承最主要的好处是代码复用.  
> 	You must also implement all abstract methods, even if they don’t make sense for your subclass.  
> 	你必须实现所有的抽象方法, 即便它们对你的子类而言没有意义.  
>   
>   
> 多态(Polymorphism)  
> 	多态是指程序能够检测出调度函数的实际对象, 并且根据继承和接口的声明去执行那个正确的函数.  


### 面向对象关系(page020-025)
> 面向对象之间的关系: 依赖、关联、聚合、组合  
>  
>  
> 依赖(Dependency)  
>	类的方法的形参中要求std::map<std::string, std::string>, 表示这个类的这个方法依赖std::map, std::string 两个类型,    
>	因为在函数体内可以调用map的方法或者string的方法, 这些方法都是公开而且不变的方法.   
>   	
>	备注: uml中没有表示依赖的表达方式    
>   
>   
> 关联(Association)   
>   关联可视为一种特殊，即一个对象总是拥有访问与其交互的对象的权限，   
>  	而简单的依赖关系并不会在对象间建立永久性的联系。   
>   
>   1. 在类中声明一个int类型的成员变量,    
>	   表示这个类依赖int类型, 因为它可以调用所有int类型的方法,    
>	   同时也表示这个类关联int类型, 因为类中的每个方法总是能访问这个成员变量的方法.   
>   
>	2. 在类中声明一个std::vector<std::string>类型的成员变量,     
>  	   表示这个类依赖 vector, string 两个类型, 因为它可以通过不同方式调用这两个类型的方法,    
> 	   同时也表示这个类关联vector, string, 因为类中的每个方法总是能访问这个成员变量的方法.   
>    
>    
> 聚合(Aggregation)   
> 	通常在聚合关系中，一个对象“拥有”一组其他对象，并扮演着容器或集合的角色。 
> 	TODO： 这里定义的并不是很清楚, 后续阅读完本书, 需要回到这里回答这个定义.   
> 	page-40-41 有讨论到聚合   
>   
>  
> 组合(Composition)   
>	TODO： 这里定义的并不是很清楚, 后续阅读完本书, 需要回到这里回答这个定义.  


### 设计原则
> 设计原则    
>    
>    
> 封装变化的内容:    
> 	找到程度中的变化内容并将其与不变的内容区分开.   
> 	如果变化的内容不复杂, 用一个函数来隔离(封装)起来即可,    
> 	如果变化的内容过于复杂, 用一个独立的类来再拆分.   
>    
>    
> 面向接口进行开发, 而不是面向实现:   
> 	与其依赖一个具体的类，不如依赖一个接口, 因为接口有明确定义某个方法, 这通常很难发生变化.   
> 	接口可以作用再, 成员变量、方法参数、抽象方法中   
> 	成员变量：声明一个接口对象, 实例化时根据特定场景初始化不同的派生类. 这种方式的     
> 	         好处是: 可以根据不同的场景去不断新增派生类来满足需求而不需要改原有代码.   
> 			 缺点是: 写代码之前都需要设计这个环节，而且设计代码时要多花点心思, 其他水平不到位的人无法直观的看懂你的代码.   
> 	方法参数：声明一个形参对象是一个接口对象, 方法内调用的都是接口方法.   
> 	         好处是: 基于该接口对象新增的对象都可以再当前方法中运行不会报错.   
> 			 缺点是：写代码之前都需要设计这个环节，而且设计代码时要多花点心思, 其他水平不到位的人无法直观的看懂你的代码.   
> 	抽象方法：声明一个抽象方法, 要求所有派生类都要各自实现这个抽象方法.   
>    
>    
> 组合优于继承   
> 	组合是代替继承的一种方法. 继承代表类之间的"是"关系(汽车是交通工具), 而组合则代表"有"关系(汽车有一个引擎).   
> 	这个原则也能用于聚合(一对一, 一对多, 多对一, 多对多). 例如: 汽车上有司机, 但是司机也可能有其他能力(骑自行车, 开拖拉机).   
> 	继承是纵向扩展，组合是横向扩展.   
>    
>    
>    
>    
>    
> SOLID原则   
>    
>    
> 单一职责原则(Single Responsibility Principle)   
> 	尽量让每个类只负责软件中的一个功能, 并将该功能完全封装(隐藏)在该类中.   
> 	一个复杂的功能, 可以使用十几个清晰的方法来完成, 总之封装就对了.   
> 	十几个方法中, 如果某个方法依旧复杂, 则可以抽出来当作另外一个类, 与当前类组合关联.   
>    
>    
> 开闭原则(Open/Closed Principle)   
> 	如果一个类已经完成开发、测试和审核工作, 那么它就是稳定的版本, 除非有明确的理由, 否则不应该对它进行改动.   
> 	如果要新增功能，或者改动功能，应该是重新写一个派生类，通过新增/覆盖的形式重写某部分功能(某些方法).   
> 	这条原则不适用于那些尚未稳定的类中, 如果在未稳定的类中, 要修改就直接修改, 稳定后采取在参考这个原则.   
>    
>    
> 里氏替换原则(Liskov Substitution Principle)   
> 	这里强调的是派生类在覆盖/替换/重写基类的方法时, 需要的注意事项, 没有什么意义, 就不要做笔记了.   
> 	重点在61-62页这两个图的类结构拆分.   
>    
>    
> 接口隔离原则(Interface Segregation Principle)   
> 	继承只允许拥有一个基类, 接口允许同时继承和实现多个接口.   
> 	将接口精细化拆分, 是有效的隔离原则.   
>    
>    
> 依赖倒置原则(Dependency Inversion Principle)   
> 	高层次的类不应该依赖低层次的类, 而是应该依赖抽象的接口.   
> 	高层次的类关联(永久拥有访问能力)低层次的类, 中间最好的方式是接口.   
>    
>    